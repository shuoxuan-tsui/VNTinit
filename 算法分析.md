# 项目核心算法分析

本文档旨在深入分析 VNTinit 项目中所采用的核心计算机科学算法，详细阐述其设计原理、性能优势以及与业务场景的深度结合方式。

---

## 1. Dijkstra 算法：最优职业发展路径规划

Dijkstra 算法是一种经典的图搜索算法，用于在加权图中寻找从一个节点到所有其他节点的最短路径。

### 1.1 算法设计 (`useGraphAlgorithms.js`)

1.  **数据结构**:

    - **图 (Graph)**: 使用 JavaScript 对象来表示。对象的键是部门名称（如图的节点），值是另一个对象，其中包含与该部门直接相连的其他部门（邻居）以及它们之间的"距离"（权重）。
    - **距离集 (distances)**: 一个对象，记录从起始部门到所有其他部门的已知最短距离，初始时，起始部门为 0，其他均为无穷大。
    - **前驱节点集 (previous)**: 一个对象，用于在找到最短路径后，从目标节点回溯以重建路径。
    - **未访问集 (unvisited)**: 一个 `Set`，存储所有尚未被访问的节点，提供了高效的添加和删除操作。

2.  **核心逻辑**:
    - **初始化**: 设置起始部门的距离为 0，其他所有部门为无穷大。
    - **迭代**: 当 `unvisited` 集合不为空时，循环执行以下操作：
      a. 从 `unvisited` 集合中找到当前已知距离最小的节点（`current`）。
      b. 将 `current` 节点从 `unvisited` 集合中移除。
      c. 对于 `current` 的每一个邻居节点，计算通过 `current` 到达该邻居的新路径长度 (`newDist`)。
      d. 如果 `newDist` 小于该邻居在 `distances` 中记录的旧距离，则更新其距离和前驱节点。
    - **路径重构**: 算法结束后，从目标部门开始，利用 `previous` 对象向前回溯，直到起始部门，从而构建出完整的最短路径。

### 1.2 性能提升

- **时间复杂度**: 标准的 Dijkstra 算法实现（如此处使用的，在未访问集合中线性查找最小值）的时间复杂度为 O(V²)，其中 V 是图中节点的数量（即部门数量）。相对于暴力搜索所有可能路径（阶乘级复杂度），这是巨大的性能提升。
- **优化**: 若部门数量非常巨大，可以通过使用优先队列（最小堆）来优化 `unvisited` 集合的查询，将时间复杂度降低到 O(E + V log V)，其中 E 是边的数量。对于本项目的中小规模部门数量，当前实现已经足够高效。

### 1.3 与项目结合

此算法并非一个孤立的函数，而是通过一系列辅助函数深度融入了"职业发展路径规划"这一业务场景。

1.  **构建加权图 (`buildDepartmentGraph`)**: 这是算法与业务结合的 **关键**。它将抽象的算法与具体的业务数据联系起来。

    - **节点**: 每个"部门"都是图的一个节点。
    - **边和权重**: 部门间的"晋升难度"作为边的权重。这个权重不是一个固定值，而是 **动态计算** 出来的，它综合了多个业务因素：
      - **薪资差异**: 两个部门平均薪资的差异。差异越大，权重越高，意味着"跨越"难度越大。
      - **部门性质**: 从技术岗转管理岗，或反之，会增加额外的难度权重。
    - 这样构建出的图，其"最短路径"的含义就不再是物理距离，而是 **职业发展综合成本最低的路径**。

2.  **寻找最优路径 (`findOptimalCareerPath`)**:
    - 这是一个面向前端的封装函数。它接收员工的当前部门和目标部门。
    - 内部调用 `buildDepartmentGraph` 构建与当前业务数据匹配的图，然后调用 `dijkstra` 算法计算最短路径。
    - 最后，它还会调用 `generateCareerRecommendations`，将算法输出的路径（如 `['技术部', '产品部', '管理部']`）转换成对用户友好的、可执行的建议列表。

---

## 2. 动态规划 (0-1 背包)：薪资预算优化

0-1 背包问题是一个经典的组合优化问题：给定一组物品，每个物品有自己的重量和价值，在不超过背包总承重的前提下，如何选择物品才能使装入背包的总价值最大。

### 2.1 算法设计 (`useDynamicProgramming.js`)

1.  **问题映射**:

    - **背包**: 公司的"薪资总预算"。
    - **物品**: 每一位"员工"。
    - **物品重量**: 员工的"薪资"。
    - **物品价值**: 员工的"绩效评分"或"贡献值"。

2.  **数据结构**:

    - **`dp` 表**: 一个二维数组 `dp[i][w]`，其核心思想是：`dp[i][w]` 表示在只考虑前 `i` 个员工，且预算上限为 `w` 的情况下，能够达到的最大总价值。
    - **`keep` 表**: 一个与 `dp` 表同样大小的布尔值二维数组，用于在填表时记录 `dp[i][w]` 的最优解是否包含了第 `i` 个员工。这是回溯以找出具体哪些员工被选中的关键。

3.  **核心逻辑**:
    - **状态转移方程**: 这是动态规划的核心。在计算 `dp[i][w]` 时，面临两种选择：
      a. **不选择第 `i` 个员工**: 那么最大价值等于只考虑前 `i-1` 个员工、预算仍为 `w` 时的最大价值，即 `dp[i-1][w]`。
      b. **选择第 `i` 个员工**: 这要求当前预算 `w` 必须大于等于该员工的薪资。此时的最大价值等于：该员工的价值 `value`，加上"在只考虑前 `i-1` 个员工、且预算为 `w - salary` 时的最大价值"，即 `value + dp[i-1][w - salary]`。
      - `dp[i][w]` 的值就是上述两种选择中的较大者。
    - **回溯**: 填完整个 `dp` 表后，从 `dp[n][budget]`（`n` 为总员工数）开始，利用 `keep` 表反向查找，如果 `keep[i][w]` 为 `true`，则说明第 `i` 个员工在最优解中，将他加入列表，并将预算 `w` 减去他的薪资，继续向上查找。

### 2.2 性能提升

- **时间复杂度**: O(N \* W)，其中 N 是员工数量，W 是预算总额。
- **对比**: 暴力解法需要尝试每位员工"选"或"不选"的所有组合，复杂度为 O(2^N)，是指数级的。动态规划通过将问题分解为重叠子问题并存储其解（备忘录思想），将复杂度降低到伪多项式时间，实现了根本性的性能提升，使得在员工数量稍多的情况下进行计算成为可能。

### 2.3 与项目结合

该算法通过 `knapsackSalaryOptimization` 函数与业务场景结合。

1.  **应用场景**: 假设公司需要进行部门重组或新项目立项，拥有一个固定的薪资预算。该算法可以帮助决策者回答："用这笔预算，应该留下或招聘哪些员工，才能使整个团队的'战斗力'（绩效总分）最强？"
2.  **前端调用**:
    - 前端会有一个"预算优化"或"团队模拟"的页面。
    - 页面上会有一个员工列表（可以从后端获取），并允许管理者为每位员工输入一个"价值评分"。
    - 管理者输入总预算后，点击"计算最优组合"按钮。
    - 前端调用 `knapsackSalaryOptimization` 函数，将员工列表（包含薪资和价值）和总预算传入。
      . 函数返回一个"最优团队"列表，前端将这个列表高亮或展示出来，并显示其总薪资成本和总价值分，为决策提供强大的数据支持。
